// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Request.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Request_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Request_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Request_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Request_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Request_2eproto;
namespace drive_protocol {
namespace request {
class CloseFileRequest;
struct CloseFileRequestDefaultTypeInternal;
extern CloseFileRequestDefaultTypeInternal _CloseFileRequest_default_instance_;
class CreateFileRequest;
struct CreateFileRequestDefaultTypeInternal;
extern CreateFileRequestDefaultTypeInternal _CreateFileRequest_default_instance_;
class CredentialInfo;
struct CredentialInfoDefaultTypeInternal;
extern CredentialInfoDefaultTypeInternal _CredentialInfo_default_instance_;
class DeleteDirectoryRequest;
struct DeleteDirectoryRequestDefaultTypeInternal;
extern DeleteDirectoryRequestDefaultTypeInternal _DeleteDirectoryRequest_default_instance_;
class DeleteFileRequest;
struct DeleteFileRequestDefaultTypeInternal;
extern DeleteFileRequestDefaultTypeInternal _DeleteFileRequest_default_instance_;
class FlushFileBufferRequest;
struct FlushFileBufferRequestDefaultTypeInternal;
extern FlushFileBufferRequestDefaultTypeInternal _FlushFileBufferRequest_default_instance_;
class GetFileInformationRequest;
struct GetFileInformationRequestDefaultTypeInternal;
extern GetFileInformationRequestDefaultTypeInternal _GetFileInformationRequest_default_instance_;
class LockFileRequest;
struct LockFileRequestDefaultTypeInternal;
extern LockFileRequestDefaultTypeInternal _LockFileRequest_default_instance_;
class MoveFileRequest;
struct MoveFileRequestDefaultTypeInternal;
extern MoveFileRequestDefaultTypeInternal _MoveFileRequest_default_instance_;
class ReadFileRequest;
struct ReadFileRequestDefaultTypeInternal;
extern ReadFileRequestDefaultTypeInternal _ReadFileRequest_default_instance_;
class RequestInfo;
struct RequestInfoDefaultTypeInternal;
extern RequestInfoDefaultTypeInternal _RequestInfo_default_instance_;
class SetAllocationSizeRequest;
struct SetAllocationSizeRequestDefaultTypeInternal;
extern SetAllocationSizeRequestDefaultTypeInternal _SetAllocationSizeRequest_default_instance_;
class SetEndOfFileRequest;
struct SetEndOfFileRequestDefaultTypeInternal;
extern SetEndOfFileRequestDefaultTypeInternal _SetEndOfFileRequest_default_instance_;
class SetFileAttributesRequest;
struct SetFileAttributesRequestDefaultTypeInternal;
extern SetFileAttributesRequestDefaultTypeInternal _SetFileAttributesRequest_default_instance_;
class UnlockFileRequest;
struct UnlockFileRequestDefaultTypeInternal;
extern UnlockFileRequestDefaultTypeInternal _UnlockFileRequest_default_instance_;
class WriteFileRequest;
struct WriteFileRequestDefaultTypeInternal;
extern WriteFileRequestDefaultTypeInternal _WriteFileRequest_default_instance_;
}  // namespace request
}  // namespace drive_protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::drive_protocol::request::CloseFileRequest* Arena::CreateMaybeMessage<::drive_protocol::request::CloseFileRequest>(Arena*);
template<> ::drive_protocol::request::CreateFileRequest* Arena::CreateMaybeMessage<::drive_protocol::request::CreateFileRequest>(Arena*);
template<> ::drive_protocol::request::CredentialInfo* Arena::CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(Arena*);
template<> ::drive_protocol::request::DeleteDirectoryRequest* Arena::CreateMaybeMessage<::drive_protocol::request::DeleteDirectoryRequest>(Arena*);
template<> ::drive_protocol::request::DeleteFileRequest* Arena::CreateMaybeMessage<::drive_protocol::request::DeleteFileRequest>(Arena*);
template<> ::drive_protocol::request::FlushFileBufferRequest* Arena::CreateMaybeMessage<::drive_protocol::request::FlushFileBufferRequest>(Arena*);
template<> ::drive_protocol::request::GetFileInformationRequest* Arena::CreateMaybeMessage<::drive_protocol::request::GetFileInformationRequest>(Arena*);
template<> ::drive_protocol::request::LockFileRequest* Arena::CreateMaybeMessage<::drive_protocol::request::LockFileRequest>(Arena*);
template<> ::drive_protocol::request::MoveFileRequest* Arena::CreateMaybeMessage<::drive_protocol::request::MoveFileRequest>(Arena*);
template<> ::drive_protocol::request::ReadFileRequest* Arena::CreateMaybeMessage<::drive_protocol::request::ReadFileRequest>(Arena*);
template<> ::drive_protocol::request::RequestInfo* Arena::CreateMaybeMessage<::drive_protocol::request::RequestInfo>(Arena*);
template<> ::drive_protocol::request::SetAllocationSizeRequest* Arena::CreateMaybeMessage<::drive_protocol::request::SetAllocationSizeRequest>(Arena*);
template<> ::drive_protocol::request::SetEndOfFileRequest* Arena::CreateMaybeMessage<::drive_protocol::request::SetEndOfFileRequest>(Arena*);
template<> ::drive_protocol::request::SetFileAttributesRequest* Arena::CreateMaybeMessage<::drive_protocol::request::SetFileAttributesRequest>(Arena*);
template<> ::drive_protocol::request::UnlockFileRequest* Arena::CreateMaybeMessage<::drive_protocol::request::UnlockFileRequest>(Arena*);
template<> ::drive_protocol::request::WriteFileRequest* Arena::CreateMaybeMessage<::drive_protocol::request::WriteFileRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace drive_protocol {
namespace request {

// ===================================================================

class RequestInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.RequestInfo) */ {
 public:
  inline RequestInfo() : RequestInfo(nullptr) {}
  ~RequestInfo() override;
  explicit constexpr RequestInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestInfo(const RequestInfo& from);
  RequestInfo(RequestInfo&& from) noexcept
    : RequestInfo() {
    *this = ::std::move(from);
  }

  inline RequestInfo& operator=(const RequestInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestInfo& operator=(RequestInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestInfo* internal_default_instance() {
    return reinterpret_cast<const RequestInfo*>(
               &_RequestInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RequestInfo& a, RequestInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.RequestInfo";
  }
  protected:
  explicit RequestInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessIdFieldNumber = 1,
    kIsDirectoryFieldNumber = 2,
    kDeleteOnCloseFieldNumber = 3,
    kPagingIoFieldNumber = 4,
    kSynchronousIoFieldNumber = 5,
    kNoCacheFieldNumber = 6,
    kWriteToEndOfFileFieldNumber = 7,
  };
  // uint64 process_id = 1;
  void clear_process_id();
  uint64_t process_id() const;
  void set_process_id(uint64_t value);
  private:
  uint64_t _internal_process_id() const;
  void _internal_set_process_id(uint64_t value);
  public:

  // bool is_directory = 2;
  void clear_is_directory();
  bool is_directory() const;
  void set_is_directory(bool value);
  private:
  bool _internal_is_directory() const;
  void _internal_set_is_directory(bool value);
  public:

  // bool delete_on_close = 3;
  void clear_delete_on_close();
  bool delete_on_close() const;
  void set_delete_on_close(bool value);
  private:
  bool _internal_delete_on_close() const;
  void _internal_set_delete_on_close(bool value);
  public:

  // bool paging_io = 4;
  void clear_paging_io();
  bool paging_io() const;
  void set_paging_io(bool value);
  private:
  bool _internal_paging_io() const;
  void _internal_set_paging_io(bool value);
  public:

  // bool synchronous_io = 5;
  void clear_synchronous_io();
  bool synchronous_io() const;
  void set_synchronous_io(bool value);
  private:
  bool _internal_synchronous_io() const;
  void _internal_set_synchronous_io(bool value);
  public:

  // bool no_cache = 6;
  void clear_no_cache();
  bool no_cache() const;
  void set_no_cache(bool value);
  private:
  bool _internal_no_cache() const;
  void _internal_set_no_cache(bool value);
  public:

  // bool write_to_end_of_file = 7;
  void clear_write_to_end_of_file();
  bool write_to_end_of_file() const;
  void set_write_to_end_of_file(bool value);
  private:
  bool _internal_write_to_end_of_file() const;
  void _internal_set_write_to_end_of_file(bool value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.request.RequestInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t process_id_;
  bool is_directory_;
  bool delete_on_close_;
  bool paging_io_;
  bool synchronous_io_;
  bool no_cache_;
  bool write_to_end_of_file_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class CredentialInfo final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:drive_protocol.request.CredentialInfo) */ {
 public:
  inline CredentialInfo() : CredentialInfo(nullptr) {}
  explicit constexpr CredentialInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CredentialInfo(const CredentialInfo& from);
  CredentialInfo(CredentialInfo&& from) noexcept
    : CredentialInfo() {
    *this = ::std::move(from);
  }

  inline CredentialInfo& operator=(const CredentialInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CredentialInfo& operator=(CredentialInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CredentialInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CredentialInfo* internal_default_instance() {
    return reinterpret_cast<const CredentialInfo*>(
               &_CredentialInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CredentialInfo& a, CredentialInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CredentialInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CredentialInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CredentialInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CredentialInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CredentialInfo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CredentialInfo& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.CredentialInfo";
  }
  protected:
  explicit CredentialInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:drive_protocol.request.CredentialInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class CreateFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.CreateFileRequest) */ {
 public:
  inline CreateFileRequest() : CreateFileRequest(nullptr) {}
  ~CreateFileRequest() override;
  explicit constexpr CreateFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateFileRequest(const CreateFileRequest& from);
  CreateFileRequest(CreateFileRequest&& from) noexcept
    : CreateFileRequest() {
    *this = ::std::move(from);
  }

  inline CreateFileRequest& operator=(const CreateFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFileRequest& operator=(CreateFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFileRequest* internal_default_instance() {
    return reinterpret_cast<const CreateFileRequest*>(
               &_CreateFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateFileRequest& a, CreateFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.CreateFileRequest";
  }
  protected:
  explicit CreateFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
    kDesiredAccessFieldNumber = 4,
    kFileAttributesFieldNumber = 5,
    kShareAccessFieldNumber = 6,
    kCreateDispositionFieldNumber = 7,
    kCreateOptionsFieldNumber = 8,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // uint64 desired_access = 4;
  void clear_desired_access();
  uint64_t desired_access() const;
  void set_desired_access(uint64_t value);
  private:
  uint64_t _internal_desired_access() const;
  void _internal_set_desired_access(uint64_t value);
  public:

  // uint64 file_attributes = 5;
  void clear_file_attributes();
  uint64_t file_attributes() const;
  void set_file_attributes(uint64_t value);
  private:
  uint64_t _internal_file_attributes() const;
  void _internal_set_file_attributes(uint64_t value);
  public:

  // uint64 share_access = 6;
  void clear_share_access();
  uint64_t share_access() const;
  void set_share_access(uint64_t value);
  private:
  uint64_t _internal_share_access() const;
  void _internal_set_share_access(uint64_t value);
  public:

  // uint64 create_disposition = 7;
  void clear_create_disposition();
  uint64_t create_disposition() const;
  void set_create_disposition(uint64_t value);
  private:
  uint64_t _internal_create_disposition() const;
  void _internal_set_create_disposition(uint64_t value);
  public:

  // uint64 create_options = 8;
  void clear_create_options();
  uint64_t create_options() const;
  void set_create_options(uint64_t value);
  private:
  uint64_t _internal_create_options() const;
  void _internal_set_create_options(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.request.CreateFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  uint64_t desired_access_;
  uint64_t file_attributes_;
  uint64_t share_access_;
  uint64_t create_disposition_;
  uint64_t create_options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class CloseFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.CloseFileRequest) */ {
 public:
  inline CloseFileRequest() : CloseFileRequest(nullptr) {}
  ~CloseFileRequest() override;
  explicit constexpr CloseFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseFileRequest(const CloseFileRequest& from);
  CloseFileRequest(CloseFileRequest&& from) noexcept
    : CloseFileRequest() {
    *this = ::std::move(from);
  }

  inline CloseFileRequest& operator=(const CloseFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseFileRequest& operator=(CloseFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseFileRequest* internal_default_instance() {
    return reinterpret_cast<const CloseFileRequest*>(
               &_CloseFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CloseFileRequest& a, CloseFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CloseFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.CloseFileRequest";
  }
  protected:
  explicit CloseFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // @@protoc_insertion_point(class_scope:drive_protocol.request.CloseFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class ReadFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.ReadFileRequest) */ {
 public:
  inline ReadFileRequest() : ReadFileRequest(nullptr) {}
  ~ReadFileRequest() override;
  explicit constexpr ReadFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadFileRequest(const ReadFileRequest& from);
  ReadFileRequest(ReadFileRequest&& from) noexcept
    : ReadFileRequest() {
    *this = ::std::move(from);
  }

  inline ReadFileRequest& operator=(const ReadFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadFileRequest& operator=(ReadFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadFileRequest* internal_default_instance() {
    return reinterpret_cast<const ReadFileRequest*>(
               &_ReadFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReadFileRequest& a, ReadFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.ReadFileRequest";
  }
  protected:
  explicit ReadFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
    kLengthFieldNumber = 4,
    kOffsetFieldNumber = 5,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // uint64 length = 4;
  void clear_length();
  uint64_t length() const;
  void set_length(uint64_t value);
  private:
  uint64_t _internal_length() const;
  void _internal_set_length(uint64_t value);
  public:

  // int64 offset = 5;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.request.ReadFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  uint64_t length_;
  int64_t offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class WriteFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.WriteFileRequest) */ {
 public:
  inline WriteFileRequest() : WriteFileRequest(nullptr) {}
  ~WriteFileRequest() override;
  explicit constexpr WriteFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteFileRequest(const WriteFileRequest& from);
  WriteFileRequest(WriteFileRequest&& from) noexcept
    : WriteFileRequest() {
    *this = ::std::move(from);
  }

  inline WriteFileRequest& operator=(const WriteFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteFileRequest& operator=(WriteFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteFileRequest* internal_default_instance() {
    return reinterpret_cast<const WriteFileRequest*>(
               &_WriteFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WriteFileRequest& a, WriteFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WriteFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.WriteFileRequest";
  }
  protected:
  explicit WriteFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kBufferFieldNumber = 6,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
    kLengthFieldNumber = 4,
    kOffsetFieldNumber = 5,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // bytes buffer = 6;
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_NODISCARD std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // uint64 length = 4;
  void clear_length();
  uint64_t length() const;
  void set_length(uint64_t value);
  private:
  uint64_t _internal_length() const;
  void _internal_set_length(uint64_t value);
  public:

  // int64 offset = 5;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.request.WriteFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  uint64_t length_;
  int64_t offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class FlushFileBufferRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.FlushFileBufferRequest) */ {
 public:
  inline FlushFileBufferRequest() : FlushFileBufferRequest(nullptr) {}
  ~FlushFileBufferRequest() override;
  explicit constexpr FlushFileBufferRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushFileBufferRequest(const FlushFileBufferRequest& from);
  FlushFileBufferRequest(FlushFileBufferRequest&& from) noexcept
    : FlushFileBufferRequest() {
    *this = ::std::move(from);
  }

  inline FlushFileBufferRequest& operator=(const FlushFileBufferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushFileBufferRequest& operator=(FlushFileBufferRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushFileBufferRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushFileBufferRequest* internal_default_instance() {
    return reinterpret_cast<const FlushFileBufferRequest*>(
               &_FlushFileBufferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FlushFileBufferRequest& a, FlushFileBufferRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushFileBufferRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushFileBufferRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushFileBufferRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushFileBufferRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushFileBufferRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FlushFileBufferRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushFileBufferRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.FlushFileBufferRequest";
  }
  protected:
  explicit FlushFileBufferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // @@protoc_insertion_point(class_scope:drive_protocol.request.FlushFileBufferRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class GetFileInformationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.GetFileInformationRequest) */ {
 public:
  inline GetFileInformationRequest() : GetFileInformationRequest(nullptr) {}
  ~GetFileInformationRequest() override;
  explicit constexpr GetFileInformationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileInformationRequest(const GetFileInformationRequest& from);
  GetFileInformationRequest(GetFileInformationRequest&& from) noexcept
    : GetFileInformationRequest() {
    *this = ::std::move(from);
  }

  inline GetFileInformationRequest& operator=(const GetFileInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileInformationRequest& operator=(GetFileInformationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileInformationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileInformationRequest* internal_default_instance() {
    return reinterpret_cast<const GetFileInformationRequest*>(
               &_GetFileInformationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetFileInformationRequest& a, GetFileInformationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileInformationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileInformationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileInformationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileInformationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileInformationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileInformationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileInformationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.GetFileInformationRequest";
  }
  protected:
  explicit GetFileInformationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // @@protoc_insertion_point(class_scope:drive_protocol.request.GetFileInformationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class DeleteFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.DeleteFileRequest) */ {
 public:
  inline DeleteFileRequest() : DeleteFileRequest(nullptr) {}
  ~DeleteFileRequest() override;
  explicit constexpr DeleteFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFileRequest(const DeleteFileRequest& from);
  DeleteFileRequest(DeleteFileRequest&& from) noexcept
    : DeleteFileRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFileRequest& operator=(const DeleteFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFileRequest& operator=(DeleteFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFileRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFileRequest*>(
               &_DeleteFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteFileRequest& a, DeleteFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.DeleteFileRequest";
  }
  protected:
  explicit DeleteFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // @@protoc_insertion_point(class_scope:drive_protocol.request.DeleteFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class DeleteDirectoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.DeleteDirectoryRequest) */ {
 public:
  inline DeleteDirectoryRequest() : DeleteDirectoryRequest(nullptr) {}
  ~DeleteDirectoryRequest() override;
  explicit constexpr DeleteDirectoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteDirectoryRequest(const DeleteDirectoryRequest& from);
  DeleteDirectoryRequest(DeleteDirectoryRequest&& from) noexcept
    : DeleteDirectoryRequest() {
    *this = ::std::move(from);
  }

  inline DeleteDirectoryRequest& operator=(const DeleteDirectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteDirectoryRequest& operator=(DeleteDirectoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteDirectoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteDirectoryRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteDirectoryRequest*>(
               &_DeleteDirectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeleteDirectoryRequest& a, DeleteDirectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteDirectoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteDirectoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteDirectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteDirectoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteDirectoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteDirectoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteDirectoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.DeleteDirectoryRequest";
  }
  protected:
  explicit DeleteDirectoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // @@protoc_insertion_point(class_scope:drive_protocol.request.DeleteDirectoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class MoveFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.MoveFileRequest) */ {
 public:
  inline MoveFileRequest() : MoveFileRequest(nullptr) {}
  ~MoveFileRequest() override;
  explicit constexpr MoveFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveFileRequest(const MoveFileRequest& from);
  MoveFileRequest(MoveFileRequest&& from) noexcept
    : MoveFileRequest() {
    *this = ::std::move(from);
  }

  inline MoveFileRequest& operator=(const MoveFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveFileRequest& operator=(MoveFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveFileRequest* internal_default_instance() {
    return reinterpret_cast<const MoveFileRequest*>(
               &_MoveFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MoveFileRequest& a, MoveFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.MoveFileRequest";
  }
  protected:
  explicit MoveFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kNewFileNameFieldNumber = 4,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
    kReplaceIfExistingFieldNumber = 5,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // string new_file_name = 4;
  void clear_new_file_name();
  const std::string& new_file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_file_name();
  PROTOBUF_NODISCARD std::string* release_new_file_name();
  void set_allocated_new_file_name(std::string* new_file_name);
  private:
  const std::string& _internal_new_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_file_name(const std::string& value);
  std::string* _internal_mutable_new_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // bool replace_if_existing = 5;
  void clear_replace_if_existing();
  bool replace_if_existing() const;
  void set_replace_if_existing(bool value);
  private:
  bool _internal_replace_if_existing() const;
  void _internal_set_replace_if_existing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.request.MoveFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  bool replace_if_existing_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class LockFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.LockFileRequest) */ {
 public:
  inline LockFileRequest() : LockFileRequest(nullptr) {}
  ~LockFileRequest() override;
  explicit constexpr LockFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LockFileRequest(const LockFileRequest& from);
  LockFileRequest(LockFileRequest&& from) noexcept
    : LockFileRequest() {
    *this = ::std::move(from);
  }

  inline LockFileRequest& operator=(const LockFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockFileRequest& operator=(LockFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LockFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockFileRequest* internal_default_instance() {
    return reinterpret_cast<const LockFileRequest*>(
               &_LockFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LockFileRequest& a, LockFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LockFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LockFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LockFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LockFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LockFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.LockFileRequest";
  }
  protected:
  explicit LockFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
    kOffsetFieldNumber = 4,
    kLengthFieldNumber = 5,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // int64 offset = 4;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // int64 length = 5;
  void clear_length();
  int64_t length() const;
  void set_length(int64_t value);
  private:
  int64_t _internal_length() const;
  void _internal_set_length(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.request.LockFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  int64_t offset_;
  int64_t length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class SetEndOfFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.SetEndOfFileRequest) */ {
 public:
  inline SetEndOfFileRequest() : SetEndOfFileRequest(nullptr) {}
  ~SetEndOfFileRequest() override;
  explicit constexpr SetEndOfFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetEndOfFileRequest(const SetEndOfFileRequest& from);
  SetEndOfFileRequest(SetEndOfFileRequest&& from) noexcept
    : SetEndOfFileRequest() {
    *this = ::std::move(from);
  }

  inline SetEndOfFileRequest& operator=(const SetEndOfFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetEndOfFileRequest& operator=(SetEndOfFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetEndOfFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetEndOfFileRequest* internal_default_instance() {
    return reinterpret_cast<const SetEndOfFileRequest*>(
               &_SetEndOfFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SetEndOfFileRequest& a, SetEndOfFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetEndOfFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetEndOfFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetEndOfFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetEndOfFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetEndOfFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetEndOfFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetEndOfFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.SetEndOfFileRequest";
  }
  protected:
  explicit SetEndOfFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
    kOffsetFieldNumber = 4,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // int64 offset = 4;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.request.SetEndOfFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  int64_t offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class SetAllocationSizeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.SetAllocationSizeRequest) */ {
 public:
  inline SetAllocationSizeRequest() : SetAllocationSizeRequest(nullptr) {}
  ~SetAllocationSizeRequest() override;
  explicit constexpr SetAllocationSizeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAllocationSizeRequest(const SetAllocationSizeRequest& from);
  SetAllocationSizeRequest(SetAllocationSizeRequest&& from) noexcept
    : SetAllocationSizeRequest() {
    *this = ::std::move(from);
  }

  inline SetAllocationSizeRequest& operator=(const SetAllocationSizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAllocationSizeRequest& operator=(SetAllocationSizeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAllocationSizeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAllocationSizeRequest* internal_default_instance() {
    return reinterpret_cast<const SetAllocationSizeRequest*>(
               &_SetAllocationSizeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SetAllocationSizeRequest& a, SetAllocationSizeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAllocationSizeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAllocationSizeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAllocationSizeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAllocationSizeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAllocationSizeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetAllocationSizeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAllocationSizeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.SetAllocationSizeRequest";
  }
  protected:
  explicit SetAllocationSizeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
    kSizeFieldNumber = 4,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // int64 size = 4;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.request.SetAllocationSizeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  int64_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class SetFileAttributesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.SetFileAttributesRequest) */ {
 public:
  inline SetFileAttributesRequest() : SetFileAttributesRequest(nullptr) {}
  ~SetFileAttributesRequest() override;
  explicit constexpr SetFileAttributesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetFileAttributesRequest(const SetFileAttributesRequest& from);
  SetFileAttributesRequest(SetFileAttributesRequest&& from) noexcept
    : SetFileAttributesRequest() {
    *this = ::std::move(from);
  }

  inline SetFileAttributesRequest& operator=(const SetFileAttributesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFileAttributesRequest& operator=(SetFileAttributesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFileAttributesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFileAttributesRequest* internal_default_instance() {
    return reinterpret_cast<const SetFileAttributesRequest*>(
               &_SetFileAttributesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SetFileAttributesRequest& a, SetFileAttributesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFileAttributesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFileAttributesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFileAttributesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFileAttributesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetFileAttributesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetFileAttributesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetFileAttributesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.SetFileAttributesRequest";
  }
  protected:
  explicit SetFileAttributesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
    kFileAttributesFieldNumber = 4,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // uint64 file_attributes = 4;
  void clear_file_attributes();
  uint64_t file_attributes() const;
  void set_file_attributes(uint64_t value);
  private:
  uint64_t _internal_file_attributes() const;
  void _internal_set_file_attributes(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.request.SetFileAttributesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  uint64_t file_attributes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// -------------------------------------------------------------------

class UnlockFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.request.UnlockFileRequest) */ {
 public:
  inline UnlockFileRequest() : UnlockFileRequest(nullptr) {}
  ~UnlockFileRequest() override;
  explicit constexpr UnlockFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockFileRequest(const UnlockFileRequest& from);
  UnlockFileRequest(UnlockFileRequest&& from) noexcept
    : UnlockFileRequest() {
    *this = ::std::move(from);
  }

  inline UnlockFileRequest& operator=(const UnlockFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockFileRequest& operator=(UnlockFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockFileRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockFileRequest*>(
               &_UnlockFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UnlockFileRequest& a, UnlockFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnlockFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.request.UnlockFileRequest";
  }
  protected:
  explicit UnlockFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 3,
    kReqFieldNumber = 1,
    kCredFieldNumber = 2,
    kOffsetFieldNumber = 4,
    kLengthFieldNumber = 5,
  };
  // string file_name = 3;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .drive_protocol.request.RequestInfo req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::drive_protocol::request::RequestInfo& req() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::RequestInfo* release_req();
  ::drive_protocol::request::RequestInfo* mutable_req();
  void set_allocated_req(::drive_protocol::request::RequestInfo* req);
  private:
  const ::drive_protocol::request::RequestInfo& _internal_req() const;
  ::drive_protocol::request::RequestInfo* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::drive_protocol::request::RequestInfo* req);
  ::drive_protocol::request::RequestInfo* unsafe_arena_release_req();

  // .drive_protocol.request.CredentialInfo cred = 2;
  bool has_cred() const;
  private:
  bool _internal_has_cred() const;
  public:
  void clear_cred();
  const ::drive_protocol::request::CredentialInfo& cred() const;
  PROTOBUF_NODISCARD ::drive_protocol::request::CredentialInfo* release_cred();
  ::drive_protocol::request::CredentialInfo* mutable_cred();
  void set_allocated_cred(::drive_protocol::request::CredentialInfo* cred);
  private:
  const ::drive_protocol::request::CredentialInfo& _internal_cred() const;
  ::drive_protocol::request::CredentialInfo* _internal_mutable_cred();
  public:
  void unsafe_arena_set_allocated_cred(
      ::drive_protocol::request::CredentialInfo* cred);
  ::drive_protocol::request::CredentialInfo* unsafe_arena_release_cred();

  // int64 offset = 4;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // int64 length = 5;
  void clear_length();
  int64_t length() const;
  void set_length(int64_t value);
  private:
  int64_t _internal_length() const;
  void _internal_set_length(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.request.UnlockFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::drive_protocol::request::RequestInfo* req_;
  ::drive_protocol::request::CredentialInfo* cred_;
  int64_t offset_;
  int64_t length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Request_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestInfo

// uint64 process_id = 1;
inline void RequestInfo::clear_process_id() {
  process_id_ = uint64_t{0u};
}
inline uint64_t RequestInfo::_internal_process_id() const {
  return process_id_;
}
inline uint64_t RequestInfo::process_id() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.RequestInfo.process_id)
  return _internal_process_id();
}
inline void RequestInfo::_internal_set_process_id(uint64_t value) {
  
  process_id_ = value;
}
inline void RequestInfo::set_process_id(uint64_t value) {
  _internal_set_process_id(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.RequestInfo.process_id)
}

// bool is_directory = 2;
inline void RequestInfo::clear_is_directory() {
  is_directory_ = false;
}
inline bool RequestInfo::_internal_is_directory() const {
  return is_directory_;
}
inline bool RequestInfo::is_directory() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.RequestInfo.is_directory)
  return _internal_is_directory();
}
inline void RequestInfo::_internal_set_is_directory(bool value) {
  
  is_directory_ = value;
}
inline void RequestInfo::set_is_directory(bool value) {
  _internal_set_is_directory(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.RequestInfo.is_directory)
}

// bool delete_on_close = 3;
inline void RequestInfo::clear_delete_on_close() {
  delete_on_close_ = false;
}
inline bool RequestInfo::_internal_delete_on_close() const {
  return delete_on_close_;
}
inline bool RequestInfo::delete_on_close() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.RequestInfo.delete_on_close)
  return _internal_delete_on_close();
}
inline void RequestInfo::_internal_set_delete_on_close(bool value) {
  
  delete_on_close_ = value;
}
inline void RequestInfo::set_delete_on_close(bool value) {
  _internal_set_delete_on_close(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.RequestInfo.delete_on_close)
}

// bool paging_io = 4;
inline void RequestInfo::clear_paging_io() {
  paging_io_ = false;
}
inline bool RequestInfo::_internal_paging_io() const {
  return paging_io_;
}
inline bool RequestInfo::paging_io() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.RequestInfo.paging_io)
  return _internal_paging_io();
}
inline void RequestInfo::_internal_set_paging_io(bool value) {
  
  paging_io_ = value;
}
inline void RequestInfo::set_paging_io(bool value) {
  _internal_set_paging_io(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.RequestInfo.paging_io)
}

// bool synchronous_io = 5;
inline void RequestInfo::clear_synchronous_io() {
  synchronous_io_ = false;
}
inline bool RequestInfo::_internal_synchronous_io() const {
  return synchronous_io_;
}
inline bool RequestInfo::synchronous_io() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.RequestInfo.synchronous_io)
  return _internal_synchronous_io();
}
inline void RequestInfo::_internal_set_synchronous_io(bool value) {
  
  synchronous_io_ = value;
}
inline void RequestInfo::set_synchronous_io(bool value) {
  _internal_set_synchronous_io(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.RequestInfo.synchronous_io)
}

// bool no_cache = 6;
inline void RequestInfo::clear_no_cache() {
  no_cache_ = false;
}
inline bool RequestInfo::_internal_no_cache() const {
  return no_cache_;
}
inline bool RequestInfo::no_cache() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.RequestInfo.no_cache)
  return _internal_no_cache();
}
inline void RequestInfo::_internal_set_no_cache(bool value) {
  
  no_cache_ = value;
}
inline void RequestInfo::set_no_cache(bool value) {
  _internal_set_no_cache(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.RequestInfo.no_cache)
}

// bool write_to_end_of_file = 7;
inline void RequestInfo::clear_write_to_end_of_file() {
  write_to_end_of_file_ = false;
}
inline bool RequestInfo::_internal_write_to_end_of_file() const {
  return write_to_end_of_file_;
}
inline bool RequestInfo::write_to_end_of_file() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.RequestInfo.write_to_end_of_file)
  return _internal_write_to_end_of_file();
}
inline void RequestInfo::_internal_set_write_to_end_of_file(bool value) {
  
  write_to_end_of_file_ = value;
}
inline void RequestInfo::set_write_to_end_of_file(bool value) {
  _internal_set_write_to_end_of_file(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.RequestInfo.write_to_end_of_file)
}

// -------------------------------------------------------------------

// CredentialInfo

// -------------------------------------------------------------------

// CreateFileRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool CreateFileRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool CreateFileRequest::has_req() const {
  return _internal_has_req();
}
inline void CreateFileRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& CreateFileRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& CreateFileRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.CreateFileRequest.req)
  return _internal_req();
}
inline void CreateFileRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.CreateFileRequest.req)
}
inline ::drive_protocol::request::RequestInfo* CreateFileRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* CreateFileRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.CreateFileRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* CreateFileRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* CreateFileRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.CreateFileRequest.req)
  return _msg;
}
inline void CreateFileRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.CreateFileRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool CreateFileRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool CreateFileRequest::has_cred() const {
  return _internal_has_cred();
}
inline void CreateFileRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& CreateFileRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& CreateFileRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.CreateFileRequest.cred)
  return _internal_cred();
}
inline void CreateFileRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.CreateFileRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* CreateFileRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* CreateFileRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.CreateFileRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* CreateFileRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* CreateFileRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.CreateFileRequest.cred)
  return _msg;
}
inline void CreateFileRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.CreateFileRequest.cred)
}

// string file_name = 3;
inline void CreateFileRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& CreateFileRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.CreateFileRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateFileRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.CreateFileRequest.file_name)
}
inline std::string* CreateFileRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.CreateFileRequest.file_name)
  return _s;
}
inline const std::string& CreateFileRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void CreateFileRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateFileRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateFileRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.CreateFileRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateFileRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.CreateFileRequest.file_name)
}

// uint64 desired_access = 4;
inline void CreateFileRequest::clear_desired_access() {
  desired_access_ = uint64_t{0u};
}
inline uint64_t CreateFileRequest::_internal_desired_access() const {
  return desired_access_;
}
inline uint64_t CreateFileRequest::desired_access() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.CreateFileRequest.desired_access)
  return _internal_desired_access();
}
inline void CreateFileRequest::_internal_set_desired_access(uint64_t value) {
  
  desired_access_ = value;
}
inline void CreateFileRequest::set_desired_access(uint64_t value) {
  _internal_set_desired_access(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.CreateFileRequest.desired_access)
}

// uint64 file_attributes = 5;
inline void CreateFileRequest::clear_file_attributes() {
  file_attributes_ = uint64_t{0u};
}
inline uint64_t CreateFileRequest::_internal_file_attributes() const {
  return file_attributes_;
}
inline uint64_t CreateFileRequest::file_attributes() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.CreateFileRequest.file_attributes)
  return _internal_file_attributes();
}
inline void CreateFileRequest::_internal_set_file_attributes(uint64_t value) {
  
  file_attributes_ = value;
}
inline void CreateFileRequest::set_file_attributes(uint64_t value) {
  _internal_set_file_attributes(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.CreateFileRequest.file_attributes)
}

// uint64 share_access = 6;
inline void CreateFileRequest::clear_share_access() {
  share_access_ = uint64_t{0u};
}
inline uint64_t CreateFileRequest::_internal_share_access() const {
  return share_access_;
}
inline uint64_t CreateFileRequest::share_access() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.CreateFileRequest.share_access)
  return _internal_share_access();
}
inline void CreateFileRequest::_internal_set_share_access(uint64_t value) {
  
  share_access_ = value;
}
inline void CreateFileRequest::set_share_access(uint64_t value) {
  _internal_set_share_access(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.CreateFileRequest.share_access)
}

// uint64 create_disposition = 7;
inline void CreateFileRequest::clear_create_disposition() {
  create_disposition_ = uint64_t{0u};
}
inline uint64_t CreateFileRequest::_internal_create_disposition() const {
  return create_disposition_;
}
inline uint64_t CreateFileRequest::create_disposition() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.CreateFileRequest.create_disposition)
  return _internal_create_disposition();
}
inline void CreateFileRequest::_internal_set_create_disposition(uint64_t value) {
  
  create_disposition_ = value;
}
inline void CreateFileRequest::set_create_disposition(uint64_t value) {
  _internal_set_create_disposition(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.CreateFileRequest.create_disposition)
}

// uint64 create_options = 8;
inline void CreateFileRequest::clear_create_options() {
  create_options_ = uint64_t{0u};
}
inline uint64_t CreateFileRequest::_internal_create_options() const {
  return create_options_;
}
inline uint64_t CreateFileRequest::create_options() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.CreateFileRequest.create_options)
  return _internal_create_options();
}
inline void CreateFileRequest::_internal_set_create_options(uint64_t value) {
  
  create_options_ = value;
}
inline void CreateFileRequest::set_create_options(uint64_t value) {
  _internal_set_create_options(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.CreateFileRequest.create_options)
}

// -------------------------------------------------------------------

// CloseFileRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool CloseFileRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool CloseFileRequest::has_req() const {
  return _internal_has_req();
}
inline void CloseFileRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& CloseFileRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& CloseFileRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.CloseFileRequest.req)
  return _internal_req();
}
inline void CloseFileRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.CloseFileRequest.req)
}
inline ::drive_protocol::request::RequestInfo* CloseFileRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* CloseFileRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.CloseFileRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* CloseFileRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* CloseFileRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.CloseFileRequest.req)
  return _msg;
}
inline void CloseFileRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.CloseFileRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool CloseFileRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool CloseFileRequest::has_cred() const {
  return _internal_has_cred();
}
inline void CloseFileRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& CloseFileRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& CloseFileRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.CloseFileRequest.cred)
  return _internal_cred();
}
inline void CloseFileRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.CloseFileRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* CloseFileRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* CloseFileRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.CloseFileRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* CloseFileRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* CloseFileRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.CloseFileRequest.cred)
  return _msg;
}
inline void CloseFileRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.CloseFileRequest.cred)
}

// string file_name = 3;
inline void CloseFileRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& CloseFileRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.CloseFileRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CloseFileRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.CloseFileRequest.file_name)
}
inline std::string* CloseFileRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.CloseFileRequest.file_name)
  return _s;
}
inline const std::string& CloseFileRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void CloseFileRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CloseFileRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CloseFileRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.CloseFileRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CloseFileRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.CloseFileRequest.file_name)
}

// -------------------------------------------------------------------

// ReadFileRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool ReadFileRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool ReadFileRequest::has_req() const {
  return _internal_has_req();
}
inline void ReadFileRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& ReadFileRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& ReadFileRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.ReadFileRequest.req)
  return _internal_req();
}
inline void ReadFileRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.ReadFileRequest.req)
}
inline ::drive_protocol::request::RequestInfo* ReadFileRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* ReadFileRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.ReadFileRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* ReadFileRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* ReadFileRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.ReadFileRequest.req)
  return _msg;
}
inline void ReadFileRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.ReadFileRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool ReadFileRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool ReadFileRequest::has_cred() const {
  return _internal_has_cred();
}
inline void ReadFileRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& ReadFileRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& ReadFileRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.ReadFileRequest.cred)
  return _internal_cred();
}
inline void ReadFileRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.ReadFileRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* ReadFileRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* ReadFileRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.ReadFileRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* ReadFileRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* ReadFileRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.ReadFileRequest.cred)
  return _msg;
}
inline void ReadFileRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.ReadFileRequest.cred)
}

// string file_name = 3;
inline void ReadFileRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& ReadFileRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.ReadFileRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadFileRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.ReadFileRequest.file_name)
}
inline std::string* ReadFileRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.ReadFileRequest.file_name)
  return _s;
}
inline const std::string& ReadFileRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void ReadFileRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadFileRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadFileRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.ReadFileRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadFileRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.ReadFileRequest.file_name)
}

// uint64 length = 4;
inline void ReadFileRequest::clear_length() {
  length_ = uint64_t{0u};
}
inline uint64_t ReadFileRequest::_internal_length() const {
  return length_;
}
inline uint64_t ReadFileRequest::length() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.ReadFileRequest.length)
  return _internal_length();
}
inline void ReadFileRequest::_internal_set_length(uint64_t value) {
  
  length_ = value;
}
inline void ReadFileRequest::set_length(uint64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.ReadFileRequest.length)
}

// int64 offset = 5;
inline void ReadFileRequest::clear_offset() {
  offset_ = int64_t{0};
}
inline int64_t ReadFileRequest::_internal_offset() const {
  return offset_;
}
inline int64_t ReadFileRequest::offset() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.ReadFileRequest.offset)
  return _internal_offset();
}
inline void ReadFileRequest::_internal_set_offset(int64_t value) {
  
  offset_ = value;
}
inline void ReadFileRequest::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.ReadFileRequest.offset)
}

// -------------------------------------------------------------------

// WriteFileRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool WriteFileRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool WriteFileRequest::has_req() const {
  return _internal_has_req();
}
inline void WriteFileRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& WriteFileRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& WriteFileRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.WriteFileRequest.req)
  return _internal_req();
}
inline void WriteFileRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.WriteFileRequest.req)
}
inline ::drive_protocol::request::RequestInfo* WriteFileRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* WriteFileRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.WriteFileRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* WriteFileRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* WriteFileRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.WriteFileRequest.req)
  return _msg;
}
inline void WriteFileRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.WriteFileRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool WriteFileRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool WriteFileRequest::has_cred() const {
  return _internal_has_cred();
}
inline void WriteFileRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& WriteFileRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& WriteFileRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.WriteFileRequest.cred)
  return _internal_cred();
}
inline void WriteFileRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.WriteFileRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* WriteFileRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* WriteFileRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.WriteFileRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* WriteFileRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* WriteFileRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.WriteFileRequest.cred)
  return _msg;
}
inline void WriteFileRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.WriteFileRequest.cred)
}

// string file_name = 3;
inline void WriteFileRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& WriteFileRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.WriteFileRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteFileRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.WriteFileRequest.file_name)
}
inline std::string* WriteFileRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.WriteFileRequest.file_name)
  return _s;
}
inline const std::string& WriteFileRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void WriteFileRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WriteFileRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WriteFileRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.WriteFileRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WriteFileRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.WriteFileRequest.file_name)
}

// uint64 length = 4;
inline void WriteFileRequest::clear_length() {
  length_ = uint64_t{0u};
}
inline uint64_t WriteFileRequest::_internal_length() const {
  return length_;
}
inline uint64_t WriteFileRequest::length() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.WriteFileRequest.length)
  return _internal_length();
}
inline void WriteFileRequest::_internal_set_length(uint64_t value) {
  
  length_ = value;
}
inline void WriteFileRequest::set_length(uint64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.WriteFileRequest.length)
}

// int64 offset = 5;
inline void WriteFileRequest::clear_offset() {
  offset_ = int64_t{0};
}
inline int64_t WriteFileRequest::_internal_offset() const {
  return offset_;
}
inline int64_t WriteFileRequest::offset() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.WriteFileRequest.offset)
  return _internal_offset();
}
inline void WriteFileRequest::_internal_set_offset(int64_t value) {
  
  offset_ = value;
}
inline void WriteFileRequest::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.WriteFileRequest.offset)
}

// bytes buffer = 6;
inline void WriteFileRequest::clear_buffer() {
  buffer_.ClearToEmpty();
}
inline const std::string& WriteFileRequest::buffer() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.WriteFileRequest.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteFileRequest::set_buffer(ArgT0&& arg0, ArgT... args) {
 
 buffer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.WriteFileRequest.buffer)
}
inline std::string* WriteFileRequest::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.WriteFileRequest.buffer)
  return _s;
}
inline const std::string& WriteFileRequest::_internal_buffer() const {
  return buffer_.Get();
}
inline void WriteFileRequest::_internal_set_buffer(const std::string& value) {
  
  buffer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WriteFileRequest::_internal_mutable_buffer() {
  
  return buffer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WriteFileRequest::release_buffer() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.WriteFileRequest.buffer)
  return buffer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WriteFileRequest::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    
  } else {
    
  }
  buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buffer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    buffer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.WriteFileRequest.buffer)
}

// -------------------------------------------------------------------

// FlushFileBufferRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool FlushFileBufferRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool FlushFileBufferRequest::has_req() const {
  return _internal_has_req();
}
inline void FlushFileBufferRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& FlushFileBufferRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& FlushFileBufferRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.FlushFileBufferRequest.req)
  return _internal_req();
}
inline void FlushFileBufferRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.FlushFileBufferRequest.req)
}
inline ::drive_protocol::request::RequestInfo* FlushFileBufferRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* FlushFileBufferRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.FlushFileBufferRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* FlushFileBufferRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* FlushFileBufferRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.FlushFileBufferRequest.req)
  return _msg;
}
inline void FlushFileBufferRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.FlushFileBufferRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool FlushFileBufferRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool FlushFileBufferRequest::has_cred() const {
  return _internal_has_cred();
}
inline void FlushFileBufferRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& FlushFileBufferRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& FlushFileBufferRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.FlushFileBufferRequest.cred)
  return _internal_cred();
}
inline void FlushFileBufferRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.FlushFileBufferRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* FlushFileBufferRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* FlushFileBufferRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.FlushFileBufferRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* FlushFileBufferRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* FlushFileBufferRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.FlushFileBufferRequest.cred)
  return _msg;
}
inline void FlushFileBufferRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.FlushFileBufferRequest.cred)
}

// string file_name = 3;
inline void FlushFileBufferRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& FlushFileBufferRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.FlushFileBufferRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FlushFileBufferRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.FlushFileBufferRequest.file_name)
}
inline std::string* FlushFileBufferRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.FlushFileBufferRequest.file_name)
  return _s;
}
inline const std::string& FlushFileBufferRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void FlushFileBufferRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FlushFileBufferRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FlushFileBufferRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.FlushFileBufferRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FlushFileBufferRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.FlushFileBufferRequest.file_name)
}

// -------------------------------------------------------------------

// GetFileInformationRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool GetFileInformationRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool GetFileInformationRequest::has_req() const {
  return _internal_has_req();
}
inline void GetFileInformationRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& GetFileInformationRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& GetFileInformationRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.GetFileInformationRequest.req)
  return _internal_req();
}
inline void GetFileInformationRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.GetFileInformationRequest.req)
}
inline ::drive_protocol::request::RequestInfo* GetFileInformationRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* GetFileInformationRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.GetFileInformationRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* GetFileInformationRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* GetFileInformationRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.GetFileInformationRequest.req)
  return _msg;
}
inline void GetFileInformationRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.GetFileInformationRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool GetFileInformationRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool GetFileInformationRequest::has_cred() const {
  return _internal_has_cred();
}
inline void GetFileInformationRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& GetFileInformationRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& GetFileInformationRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.GetFileInformationRequest.cred)
  return _internal_cred();
}
inline void GetFileInformationRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.GetFileInformationRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* GetFileInformationRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* GetFileInformationRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.GetFileInformationRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* GetFileInformationRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* GetFileInformationRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.GetFileInformationRequest.cred)
  return _msg;
}
inline void GetFileInformationRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.GetFileInformationRequest.cred)
}

// string file_name = 3;
inline void GetFileInformationRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& GetFileInformationRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.GetFileInformationRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetFileInformationRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.GetFileInformationRequest.file_name)
}
inline std::string* GetFileInformationRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.GetFileInformationRequest.file_name)
  return _s;
}
inline const std::string& GetFileInformationRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void GetFileInformationRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetFileInformationRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetFileInformationRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.GetFileInformationRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetFileInformationRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.GetFileInformationRequest.file_name)
}

// -------------------------------------------------------------------

// DeleteFileRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool DeleteFileRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool DeleteFileRequest::has_req() const {
  return _internal_has_req();
}
inline void DeleteFileRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& DeleteFileRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& DeleteFileRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.DeleteFileRequest.req)
  return _internal_req();
}
inline void DeleteFileRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.DeleteFileRequest.req)
}
inline ::drive_protocol::request::RequestInfo* DeleteFileRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* DeleteFileRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.DeleteFileRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* DeleteFileRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* DeleteFileRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.DeleteFileRequest.req)
  return _msg;
}
inline void DeleteFileRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.DeleteFileRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool DeleteFileRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool DeleteFileRequest::has_cred() const {
  return _internal_has_cred();
}
inline void DeleteFileRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& DeleteFileRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& DeleteFileRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.DeleteFileRequest.cred)
  return _internal_cred();
}
inline void DeleteFileRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.DeleteFileRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* DeleteFileRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* DeleteFileRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.DeleteFileRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* DeleteFileRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* DeleteFileRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.DeleteFileRequest.cred)
  return _msg;
}
inline void DeleteFileRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.DeleteFileRequest.cred)
}

// string file_name = 3;
inline void DeleteFileRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& DeleteFileRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.DeleteFileRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteFileRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.DeleteFileRequest.file_name)
}
inline std::string* DeleteFileRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.DeleteFileRequest.file_name)
  return _s;
}
inline const std::string& DeleteFileRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void DeleteFileRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteFileRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.DeleteFileRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteFileRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.DeleteFileRequest.file_name)
}

// -------------------------------------------------------------------

// DeleteDirectoryRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool DeleteDirectoryRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool DeleteDirectoryRequest::has_req() const {
  return _internal_has_req();
}
inline void DeleteDirectoryRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& DeleteDirectoryRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& DeleteDirectoryRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.DeleteDirectoryRequest.req)
  return _internal_req();
}
inline void DeleteDirectoryRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.DeleteDirectoryRequest.req)
}
inline ::drive_protocol::request::RequestInfo* DeleteDirectoryRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* DeleteDirectoryRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.DeleteDirectoryRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* DeleteDirectoryRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* DeleteDirectoryRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.DeleteDirectoryRequest.req)
  return _msg;
}
inline void DeleteDirectoryRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.DeleteDirectoryRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool DeleteDirectoryRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool DeleteDirectoryRequest::has_cred() const {
  return _internal_has_cred();
}
inline void DeleteDirectoryRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& DeleteDirectoryRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& DeleteDirectoryRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.DeleteDirectoryRequest.cred)
  return _internal_cred();
}
inline void DeleteDirectoryRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.DeleteDirectoryRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* DeleteDirectoryRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* DeleteDirectoryRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.DeleteDirectoryRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* DeleteDirectoryRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* DeleteDirectoryRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.DeleteDirectoryRequest.cred)
  return _msg;
}
inline void DeleteDirectoryRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.DeleteDirectoryRequest.cred)
}

// string file_name = 3;
inline void DeleteDirectoryRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& DeleteDirectoryRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.DeleteDirectoryRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteDirectoryRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.DeleteDirectoryRequest.file_name)
}
inline std::string* DeleteDirectoryRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.DeleteDirectoryRequest.file_name)
  return _s;
}
inline const std::string& DeleteDirectoryRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void DeleteDirectoryRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteDirectoryRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteDirectoryRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.DeleteDirectoryRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteDirectoryRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.DeleteDirectoryRequest.file_name)
}

// -------------------------------------------------------------------

// MoveFileRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool MoveFileRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool MoveFileRequest::has_req() const {
  return _internal_has_req();
}
inline void MoveFileRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& MoveFileRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& MoveFileRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.MoveFileRequest.req)
  return _internal_req();
}
inline void MoveFileRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.MoveFileRequest.req)
}
inline ::drive_protocol::request::RequestInfo* MoveFileRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* MoveFileRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.MoveFileRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* MoveFileRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* MoveFileRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.MoveFileRequest.req)
  return _msg;
}
inline void MoveFileRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.MoveFileRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool MoveFileRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool MoveFileRequest::has_cred() const {
  return _internal_has_cred();
}
inline void MoveFileRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& MoveFileRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& MoveFileRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.MoveFileRequest.cred)
  return _internal_cred();
}
inline void MoveFileRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.MoveFileRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* MoveFileRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* MoveFileRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.MoveFileRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* MoveFileRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* MoveFileRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.MoveFileRequest.cred)
  return _msg;
}
inline void MoveFileRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.MoveFileRequest.cred)
}

// string file_name = 3;
inline void MoveFileRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& MoveFileRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.MoveFileRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveFileRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.MoveFileRequest.file_name)
}
inline std::string* MoveFileRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.MoveFileRequest.file_name)
  return _s;
}
inline const std::string& MoveFileRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void MoveFileRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MoveFileRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MoveFileRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.MoveFileRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MoveFileRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.MoveFileRequest.file_name)
}

// string new_file_name = 4;
inline void MoveFileRequest::clear_new_file_name() {
  new_file_name_.ClearToEmpty();
}
inline const std::string& MoveFileRequest::new_file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.MoveFileRequest.new_file_name)
  return _internal_new_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveFileRequest::set_new_file_name(ArgT0&& arg0, ArgT... args) {
 
 new_file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.MoveFileRequest.new_file_name)
}
inline std::string* MoveFileRequest::mutable_new_file_name() {
  std::string* _s = _internal_mutable_new_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.MoveFileRequest.new_file_name)
  return _s;
}
inline const std::string& MoveFileRequest::_internal_new_file_name() const {
  return new_file_name_.Get();
}
inline void MoveFileRequest::_internal_set_new_file_name(const std::string& value) {
  
  new_file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MoveFileRequest::_internal_mutable_new_file_name() {
  
  return new_file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MoveFileRequest::release_new_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.MoveFileRequest.new_file_name)
  return new_file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MoveFileRequest::set_allocated_new_file_name(std::string* new_file_name) {
  if (new_file_name != nullptr) {
    
  } else {
    
  }
  new_file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    new_file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.MoveFileRequest.new_file_name)
}

// bool replace_if_existing = 5;
inline void MoveFileRequest::clear_replace_if_existing() {
  replace_if_existing_ = false;
}
inline bool MoveFileRequest::_internal_replace_if_existing() const {
  return replace_if_existing_;
}
inline bool MoveFileRequest::replace_if_existing() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.MoveFileRequest.replace_if_existing)
  return _internal_replace_if_existing();
}
inline void MoveFileRequest::_internal_set_replace_if_existing(bool value) {
  
  replace_if_existing_ = value;
}
inline void MoveFileRequest::set_replace_if_existing(bool value) {
  _internal_set_replace_if_existing(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.MoveFileRequest.replace_if_existing)
}

// -------------------------------------------------------------------

// LockFileRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool LockFileRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool LockFileRequest::has_req() const {
  return _internal_has_req();
}
inline void LockFileRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& LockFileRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& LockFileRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.LockFileRequest.req)
  return _internal_req();
}
inline void LockFileRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.LockFileRequest.req)
}
inline ::drive_protocol::request::RequestInfo* LockFileRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* LockFileRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.LockFileRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* LockFileRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* LockFileRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.LockFileRequest.req)
  return _msg;
}
inline void LockFileRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.LockFileRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool LockFileRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool LockFileRequest::has_cred() const {
  return _internal_has_cred();
}
inline void LockFileRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& LockFileRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& LockFileRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.LockFileRequest.cred)
  return _internal_cred();
}
inline void LockFileRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.LockFileRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* LockFileRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* LockFileRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.LockFileRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* LockFileRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* LockFileRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.LockFileRequest.cred)
  return _msg;
}
inline void LockFileRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.LockFileRequest.cred)
}

// string file_name = 3;
inline void LockFileRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& LockFileRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.LockFileRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LockFileRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.LockFileRequest.file_name)
}
inline std::string* LockFileRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.LockFileRequest.file_name)
  return _s;
}
inline const std::string& LockFileRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void LockFileRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LockFileRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LockFileRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.LockFileRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LockFileRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.LockFileRequest.file_name)
}

// int64 offset = 4;
inline void LockFileRequest::clear_offset() {
  offset_ = int64_t{0};
}
inline int64_t LockFileRequest::_internal_offset() const {
  return offset_;
}
inline int64_t LockFileRequest::offset() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.LockFileRequest.offset)
  return _internal_offset();
}
inline void LockFileRequest::_internal_set_offset(int64_t value) {
  
  offset_ = value;
}
inline void LockFileRequest::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.LockFileRequest.offset)
}

// int64 length = 5;
inline void LockFileRequest::clear_length() {
  length_ = int64_t{0};
}
inline int64_t LockFileRequest::_internal_length() const {
  return length_;
}
inline int64_t LockFileRequest::length() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.LockFileRequest.length)
  return _internal_length();
}
inline void LockFileRequest::_internal_set_length(int64_t value) {
  
  length_ = value;
}
inline void LockFileRequest::set_length(int64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.LockFileRequest.length)
}

// -------------------------------------------------------------------

// SetEndOfFileRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool SetEndOfFileRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool SetEndOfFileRequest::has_req() const {
  return _internal_has_req();
}
inline void SetEndOfFileRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& SetEndOfFileRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& SetEndOfFileRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.SetEndOfFileRequest.req)
  return _internal_req();
}
inline void SetEndOfFileRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.SetEndOfFileRequest.req)
}
inline ::drive_protocol::request::RequestInfo* SetEndOfFileRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* SetEndOfFileRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.SetEndOfFileRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* SetEndOfFileRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* SetEndOfFileRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.SetEndOfFileRequest.req)
  return _msg;
}
inline void SetEndOfFileRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.SetEndOfFileRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool SetEndOfFileRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool SetEndOfFileRequest::has_cred() const {
  return _internal_has_cred();
}
inline void SetEndOfFileRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& SetEndOfFileRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& SetEndOfFileRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.SetEndOfFileRequest.cred)
  return _internal_cred();
}
inline void SetEndOfFileRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.SetEndOfFileRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* SetEndOfFileRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* SetEndOfFileRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.SetEndOfFileRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* SetEndOfFileRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* SetEndOfFileRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.SetEndOfFileRequest.cred)
  return _msg;
}
inline void SetEndOfFileRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.SetEndOfFileRequest.cred)
}

// string file_name = 3;
inline void SetEndOfFileRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& SetEndOfFileRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.SetEndOfFileRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetEndOfFileRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.SetEndOfFileRequest.file_name)
}
inline std::string* SetEndOfFileRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.SetEndOfFileRequest.file_name)
  return _s;
}
inline const std::string& SetEndOfFileRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void SetEndOfFileRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetEndOfFileRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetEndOfFileRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.SetEndOfFileRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetEndOfFileRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.SetEndOfFileRequest.file_name)
}

// int64 offset = 4;
inline void SetEndOfFileRequest::clear_offset() {
  offset_ = int64_t{0};
}
inline int64_t SetEndOfFileRequest::_internal_offset() const {
  return offset_;
}
inline int64_t SetEndOfFileRequest::offset() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.SetEndOfFileRequest.offset)
  return _internal_offset();
}
inline void SetEndOfFileRequest::_internal_set_offset(int64_t value) {
  
  offset_ = value;
}
inline void SetEndOfFileRequest::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.SetEndOfFileRequest.offset)
}

// -------------------------------------------------------------------

// SetAllocationSizeRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool SetAllocationSizeRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool SetAllocationSizeRequest::has_req() const {
  return _internal_has_req();
}
inline void SetAllocationSizeRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& SetAllocationSizeRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& SetAllocationSizeRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.SetAllocationSizeRequest.req)
  return _internal_req();
}
inline void SetAllocationSizeRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.SetAllocationSizeRequest.req)
}
inline ::drive_protocol::request::RequestInfo* SetAllocationSizeRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* SetAllocationSizeRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.SetAllocationSizeRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* SetAllocationSizeRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* SetAllocationSizeRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.SetAllocationSizeRequest.req)
  return _msg;
}
inline void SetAllocationSizeRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.SetAllocationSizeRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool SetAllocationSizeRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool SetAllocationSizeRequest::has_cred() const {
  return _internal_has_cred();
}
inline void SetAllocationSizeRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& SetAllocationSizeRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& SetAllocationSizeRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.SetAllocationSizeRequest.cred)
  return _internal_cred();
}
inline void SetAllocationSizeRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.SetAllocationSizeRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* SetAllocationSizeRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* SetAllocationSizeRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.SetAllocationSizeRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* SetAllocationSizeRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* SetAllocationSizeRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.SetAllocationSizeRequest.cred)
  return _msg;
}
inline void SetAllocationSizeRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.SetAllocationSizeRequest.cred)
}

// string file_name = 3;
inline void SetAllocationSizeRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& SetAllocationSizeRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.SetAllocationSizeRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAllocationSizeRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.SetAllocationSizeRequest.file_name)
}
inline std::string* SetAllocationSizeRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.SetAllocationSizeRequest.file_name)
  return _s;
}
inline const std::string& SetAllocationSizeRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void SetAllocationSizeRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetAllocationSizeRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetAllocationSizeRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.SetAllocationSizeRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetAllocationSizeRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.SetAllocationSizeRequest.file_name)
}

// int64 size = 4;
inline void SetAllocationSizeRequest::clear_size() {
  size_ = int64_t{0};
}
inline int64_t SetAllocationSizeRequest::_internal_size() const {
  return size_;
}
inline int64_t SetAllocationSizeRequest::size() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.SetAllocationSizeRequest.size)
  return _internal_size();
}
inline void SetAllocationSizeRequest::_internal_set_size(int64_t value) {
  
  size_ = value;
}
inline void SetAllocationSizeRequest::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.SetAllocationSizeRequest.size)
}

// -------------------------------------------------------------------

// SetFileAttributesRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool SetFileAttributesRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool SetFileAttributesRequest::has_req() const {
  return _internal_has_req();
}
inline void SetFileAttributesRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& SetFileAttributesRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& SetFileAttributesRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.SetFileAttributesRequest.req)
  return _internal_req();
}
inline void SetFileAttributesRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.SetFileAttributesRequest.req)
}
inline ::drive_protocol::request::RequestInfo* SetFileAttributesRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* SetFileAttributesRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.SetFileAttributesRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* SetFileAttributesRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* SetFileAttributesRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.SetFileAttributesRequest.req)
  return _msg;
}
inline void SetFileAttributesRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.SetFileAttributesRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool SetFileAttributesRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool SetFileAttributesRequest::has_cred() const {
  return _internal_has_cred();
}
inline void SetFileAttributesRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& SetFileAttributesRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& SetFileAttributesRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.SetFileAttributesRequest.cred)
  return _internal_cred();
}
inline void SetFileAttributesRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.SetFileAttributesRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* SetFileAttributesRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* SetFileAttributesRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.SetFileAttributesRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* SetFileAttributesRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* SetFileAttributesRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.SetFileAttributesRequest.cred)
  return _msg;
}
inline void SetFileAttributesRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.SetFileAttributesRequest.cred)
}

// string file_name = 3;
inline void SetFileAttributesRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& SetFileAttributesRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.SetFileAttributesRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetFileAttributesRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.SetFileAttributesRequest.file_name)
}
inline std::string* SetFileAttributesRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.SetFileAttributesRequest.file_name)
  return _s;
}
inline const std::string& SetFileAttributesRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void SetFileAttributesRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetFileAttributesRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetFileAttributesRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.SetFileAttributesRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetFileAttributesRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.SetFileAttributesRequest.file_name)
}

// uint64 file_attributes = 4;
inline void SetFileAttributesRequest::clear_file_attributes() {
  file_attributes_ = uint64_t{0u};
}
inline uint64_t SetFileAttributesRequest::_internal_file_attributes() const {
  return file_attributes_;
}
inline uint64_t SetFileAttributesRequest::file_attributes() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.SetFileAttributesRequest.file_attributes)
  return _internal_file_attributes();
}
inline void SetFileAttributesRequest::_internal_set_file_attributes(uint64_t value) {
  
  file_attributes_ = value;
}
inline void SetFileAttributesRequest::set_file_attributes(uint64_t value) {
  _internal_set_file_attributes(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.SetFileAttributesRequest.file_attributes)
}

// -------------------------------------------------------------------

// UnlockFileRequest

// .drive_protocol.request.RequestInfo req = 1;
inline bool UnlockFileRequest::_internal_has_req() const {
  return this != internal_default_instance() && req_ != nullptr;
}
inline bool UnlockFileRequest::has_req() const {
  return _internal_has_req();
}
inline void UnlockFileRequest::clear_req() {
  if (GetArenaForAllocation() == nullptr && req_ != nullptr) {
    delete req_;
  }
  req_ = nullptr;
}
inline const ::drive_protocol::request::RequestInfo& UnlockFileRequest::_internal_req() const {
  const ::drive_protocol::request::RequestInfo* p = req_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::RequestInfo&>(
      ::drive_protocol::request::_RequestInfo_default_instance_);
}
inline const ::drive_protocol::request::RequestInfo& UnlockFileRequest::req() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.UnlockFileRequest.req)
  return _internal_req();
}
inline void UnlockFileRequest::unsafe_arena_set_allocated_req(
    ::drive_protocol::request::RequestInfo* req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.UnlockFileRequest.req)
}
inline ::drive_protocol::request::RequestInfo* UnlockFileRequest::release_req() {
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::RequestInfo* UnlockFileRequest::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.UnlockFileRequest.req)
  
  ::drive_protocol::request::RequestInfo* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::RequestInfo* UnlockFileRequest::_internal_mutable_req() {
  
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::RequestInfo>(GetArenaForAllocation());
    req_ = p;
  }
  return req_;
}
inline ::drive_protocol::request::RequestInfo* UnlockFileRequest::mutable_req() {
  ::drive_protocol::request::RequestInfo* _msg = _internal_mutable_req();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.UnlockFileRequest.req)
  return _msg;
}
inline void UnlockFileRequest::set_allocated_req(::drive_protocol::request::RequestInfo* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete req_;
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::RequestInfo>::GetOwningArena(req);
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    
  } else {
    
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.UnlockFileRequest.req)
}

// .drive_protocol.request.CredentialInfo cred = 2;
inline bool UnlockFileRequest::_internal_has_cred() const {
  return this != internal_default_instance() && cred_ != nullptr;
}
inline bool UnlockFileRequest::has_cred() const {
  return _internal_has_cred();
}
inline void UnlockFileRequest::clear_cred() {
  if (GetArenaForAllocation() == nullptr && cred_ != nullptr) {
    delete cred_;
  }
  cred_ = nullptr;
}
inline const ::drive_protocol::request::CredentialInfo& UnlockFileRequest::_internal_cred() const {
  const ::drive_protocol::request::CredentialInfo* p = cred_;
  return p != nullptr ? *p : reinterpret_cast<const ::drive_protocol::request::CredentialInfo&>(
      ::drive_protocol::request::_CredentialInfo_default_instance_);
}
inline const ::drive_protocol::request::CredentialInfo& UnlockFileRequest::cred() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.UnlockFileRequest.cred)
  return _internal_cred();
}
inline void UnlockFileRequest::unsafe_arena_set_allocated_cred(
    ::drive_protocol::request::CredentialInfo* cred) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cred_);
  }
  cred_ = cred;
  if (cred) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive_protocol.request.UnlockFileRequest.cred)
}
inline ::drive_protocol::request::CredentialInfo* UnlockFileRequest::release_cred() {
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* UnlockFileRequest::unsafe_arena_release_cred() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.UnlockFileRequest.cred)
  
  ::drive_protocol::request::CredentialInfo* temp = cred_;
  cred_ = nullptr;
  return temp;
}
inline ::drive_protocol::request::CredentialInfo* UnlockFileRequest::_internal_mutable_cred() {
  
  if (cred_ == nullptr) {
    auto* p = CreateMaybeMessage<::drive_protocol::request::CredentialInfo>(GetArenaForAllocation());
    cred_ = p;
  }
  return cred_;
}
inline ::drive_protocol::request::CredentialInfo* UnlockFileRequest::mutable_cred() {
  ::drive_protocol::request::CredentialInfo* _msg = _internal_mutable_cred();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.UnlockFileRequest.cred)
  return _msg;
}
inline void UnlockFileRequest::set_allocated_cred(::drive_protocol::request::CredentialInfo* cred) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cred_;
  }
  if (cred) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::drive_protocol::request::CredentialInfo>::GetOwningArena(cred);
    if (message_arena != submessage_arena) {
      cred = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cred, submessage_arena);
    }
    
  } else {
    
  }
  cred_ = cred;
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.UnlockFileRequest.cred)
}

// string file_name = 3;
inline void UnlockFileRequest::clear_file_name() {
  file_name_.ClearToEmpty();
}
inline const std::string& UnlockFileRequest::file_name() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.UnlockFileRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnlockFileRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.request.UnlockFileRequest.file_name)
}
inline std::string* UnlockFileRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:drive_protocol.request.UnlockFileRequest.file_name)
  return _s;
}
inline const std::string& UnlockFileRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void UnlockFileRequest::_internal_set_file_name(const std::string& value) {
  
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnlockFileRequest::_internal_mutable_file_name() {
  
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnlockFileRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:drive_protocol.request.UnlockFileRequest.file_name)
  return file_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnlockFileRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.request.UnlockFileRequest.file_name)
}

// int64 offset = 4;
inline void UnlockFileRequest::clear_offset() {
  offset_ = int64_t{0};
}
inline int64_t UnlockFileRequest::_internal_offset() const {
  return offset_;
}
inline int64_t UnlockFileRequest::offset() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.UnlockFileRequest.offset)
  return _internal_offset();
}
inline void UnlockFileRequest::_internal_set_offset(int64_t value) {
  
  offset_ = value;
}
inline void UnlockFileRequest::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.UnlockFileRequest.offset)
}

// int64 length = 5;
inline void UnlockFileRequest::clear_length() {
  length_ = int64_t{0};
}
inline int64_t UnlockFileRequest::_internal_length() const {
  return length_;
}
inline int64_t UnlockFileRequest::length() const {
  // @@protoc_insertion_point(field_get:drive_protocol.request.UnlockFileRequest.length)
  return _internal_length();
}
inline void UnlockFileRequest::_internal_set_length(int64_t value) {
  
  length_ = value;
}
inline void UnlockFileRequest::set_length(int64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:drive_protocol.request.UnlockFileRequest.length)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace request
}  // namespace drive_protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Request_2eproto
