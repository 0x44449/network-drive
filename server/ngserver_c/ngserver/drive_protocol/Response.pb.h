// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Response.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Response_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Response_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Response_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Response_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Response_2eproto;
namespace drive_protocol {
namespace response {
class CloseFileResponse;
struct CloseFileResponseDefaultTypeInternal;
extern CloseFileResponseDefaultTypeInternal _CloseFileResponse_default_instance_;
class CreateFileResponse;
struct CreateFileResponseDefaultTypeInternal;
extern CreateFileResponseDefaultTypeInternal _CreateFileResponse_default_instance_;
class DeleteDirectoryResponse;
struct DeleteDirectoryResponseDefaultTypeInternal;
extern DeleteDirectoryResponseDefaultTypeInternal _DeleteDirectoryResponse_default_instance_;
class DeleteFileResponse;
struct DeleteFileResponseDefaultTypeInternal;
extern DeleteFileResponseDefaultTypeInternal _DeleteFileResponse_default_instance_;
class FlushFileBufferResponse;
struct FlushFileBufferResponseDefaultTypeInternal;
extern FlushFileBufferResponseDefaultTypeInternal _FlushFileBufferResponse_default_instance_;
class GetFileInformationResponse;
struct GetFileInformationResponseDefaultTypeInternal;
extern GetFileInformationResponseDefaultTypeInternal _GetFileInformationResponse_default_instance_;
class LockFileResponse;
struct LockFileResponseDefaultTypeInternal;
extern LockFileResponseDefaultTypeInternal _LockFileResponse_default_instance_;
class MoveFileResponse;
struct MoveFileResponseDefaultTypeInternal;
extern MoveFileResponseDefaultTypeInternal _MoveFileResponse_default_instance_;
class ReadFileResponse;
struct ReadFileResponseDefaultTypeInternal;
extern ReadFileResponseDefaultTypeInternal _ReadFileResponse_default_instance_;
class SetAllocationSizeResponse;
struct SetAllocationSizeResponseDefaultTypeInternal;
extern SetAllocationSizeResponseDefaultTypeInternal _SetAllocationSizeResponse_default_instance_;
class SetEndOfFileResponse;
struct SetEndOfFileResponseDefaultTypeInternal;
extern SetEndOfFileResponseDefaultTypeInternal _SetEndOfFileResponse_default_instance_;
class SetFileAttributesResponse;
struct SetFileAttributesResponseDefaultTypeInternal;
extern SetFileAttributesResponseDefaultTypeInternal _SetFileAttributesResponse_default_instance_;
class UnlockFileResponse;
struct UnlockFileResponseDefaultTypeInternal;
extern UnlockFileResponseDefaultTypeInternal _UnlockFileResponse_default_instance_;
class WriteFileResponse;
struct WriteFileResponseDefaultTypeInternal;
extern WriteFileResponseDefaultTypeInternal _WriteFileResponse_default_instance_;
}  // namespace response
}  // namespace drive_protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::drive_protocol::response::CloseFileResponse* Arena::CreateMaybeMessage<::drive_protocol::response::CloseFileResponse>(Arena*);
template<> ::drive_protocol::response::CreateFileResponse* Arena::CreateMaybeMessage<::drive_protocol::response::CreateFileResponse>(Arena*);
template<> ::drive_protocol::response::DeleteDirectoryResponse* Arena::CreateMaybeMessage<::drive_protocol::response::DeleteDirectoryResponse>(Arena*);
template<> ::drive_protocol::response::DeleteFileResponse* Arena::CreateMaybeMessage<::drive_protocol::response::DeleteFileResponse>(Arena*);
template<> ::drive_protocol::response::FlushFileBufferResponse* Arena::CreateMaybeMessage<::drive_protocol::response::FlushFileBufferResponse>(Arena*);
template<> ::drive_protocol::response::GetFileInformationResponse* Arena::CreateMaybeMessage<::drive_protocol::response::GetFileInformationResponse>(Arena*);
template<> ::drive_protocol::response::LockFileResponse* Arena::CreateMaybeMessage<::drive_protocol::response::LockFileResponse>(Arena*);
template<> ::drive_protocol::response::MoveFileResponse* Arena::CreateMaybeMessage<::drive_protocol::response::MoveFileResponse>(Arena*);
template<> ::drive_protocol::response::ReadFileResponse* Arena::CreateMaybeMessage<::drive_protocol::response::ReadFileResponse>(Arena*);
template<> ::drive_protocol::response::SetAllocationSizeResponse* Arena::CreateMaybeMessage<::drive_protocol::response::SetAllocationSizeResponse>(Arena*);
template<> ::drive_protocol::response::SetEndOfFileResponse* Arena::CreateMaybeMessage<::drive_protocol::response::SetEndOfFileResponse>(Arena*);
template<> ::drive_protocol::response::SetFileAttributesResponse* Arena::CreateMaybeMessage<::drive_protocol::response::SetFileAttributesResponse>(Arena*);
template<> ::drive_protocol::response::UnlockFileResponse* Arena::CreateMaybeMessage<::drive_protocol::response::UnlockFileResponse>(Arena*);
template<> ::drive_protocol::response::WriteFileResponse* Arena::CreateMaybeMessage<::drive_protocol::response::WriteFileResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace drive_protocol {
namespace response {

// ===================================================================

class CreateFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.CreateFileResponse) */ {
 public:
  inline CreateFileResponse() : CreateFileResponse(nullptr) {}
  ~CreateFileResponse() override;
  explicit constexpr CreateFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateFileResponse(const CreateFileResponse& from);
  CreateFileResponse(CreateFileResponse&& from) noexcept
    : CreateFileResponse() {
    *this = ::std::move(from);
  }

  inline CreateFileResponse& operator=(const CreateFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateFileResponse& operator=(CreateFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateFileResponse* internal_default_instance() {
    return reinterpret_cast<const CreateFileResponse*>(
               &_CreateFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateFileResponse& a, CreateFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.CreateFileResponse";
  }
  protected:
  explicit CreateFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.CreateFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class CloseFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.CloseFileResponse) */ {
 public:
  inline CloseFileResponse() : CloseFileResponse(nullptr) {}
  ~CloseFileResponse() override;
  explicit constexpr CloseFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseFileResponse(const CloseFileResponse& from);
  CloseFileResponse(CloseFileResponse&& from) noexcept
    : CloseFileResponse() {
    *this = ::std::move(from);
  }

  inline CloseFileResponse& operator=(const CloseFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseFileResponse& operator=(CloseFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseFileResponse* internal_default_instance() {
    return reinterpret_cast<const CloseFileResponse*>(
               &_CloseFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CloseFileResponse& a, CloseFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CloseFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.CloseFileResponse";
  }
  protected:
  explicit CloseFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.CloseFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class ReadFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.ReadFileResponse) */ {
 public:
  inline ReadFileResponse() : ReadFileResponse(nullptr) {}
  ~ReadFileResponse() override;
  explicit constexpr ReadFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadFileResponse(const ReadFileResponse& from);
  ReadFileResponse(ReadFileResponse&& from) noexcept
    : ReadFileResponse() {
    *this = ::std::move(from);
  }

  inline ReadFileResponse& operator=(const ReadFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadFileResponse& operator=(ReadFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadFileResponse* internal_default_instance() {
    return reinterpret_cast<const ReadFileResponse*>(
               &_ReadFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReadFileResponse& a, ReadFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.ReadFileResponse";
  }
  protected:
  explicit ReadFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // bytes buffer = 2;
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_NODISCARD std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.ReadFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class WriteFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.WriteFileResponse) */ {
 public:
  inline WriteFileResponse() : WriteFileResponse(nullptr) {}
  ~WriteFileResponse() override;
  explicit constexpr WriteFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteFileResponse(const WriteFileResponse& from);
  WriteFileResponse(WriteFileResponse&& from) noexcept
    : WriteFileResponse() {
    *this = ::std::move(from);
  }

  inline WriteFileResponse& operator=(const WriteFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteFileResponse& operator=(WriteFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteFileResponse* internal_default_instance() {
    return reinterpret_cast<const WriteFileResponse*>(
               &_WriteFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WriteFileResponse& a, WriteFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WriteFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.WriteFileResponse";
  }
  protected:
  explicit WriteFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.WriteFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class FlushFileBufferResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.FlushFileBufferResponse) */ {
 public:
  inline FlushFileBufferResponse() : FlushFileBufferResponse(nullptr) {}
  ~FlushFileBufferResponse() override;
  explicit constexpr FlushFileBufferResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlushFileBufferResponse(const FlushFileBufferResponse& from);
  FlushFileBufferResponse(FlushFileBufferResponse&& from) noexcept
    : FlushFileBufferResponse() {
    *this = ::std::move(from);
  }

  inline FlushFileBufferResponse& operator=(const FlushFileBufferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushFileBufferResponse& operator=(FlushFileBufferResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlushFileBufferResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlushFileBufferResponse* internal_default_instance() {
    return reinterpret_cast<const FlushFileBufferResponse*>(
               &_FlushFileBufferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FlushFileBufferResponse& a, FlushFileBufferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushFileBufferResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlushFileBufferResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlushFileBufferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlushFileBufferResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlushFileBufferResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FlushFileBufferResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushFileBufferResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.FlushFileBufferResponse";
  }
  protected:
  explicit FlushFileBufferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.FlushFileBufferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class GetFileInformationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.GetFileInformationResponse) */ {
 public:
  inline GetFileInformationResponse() : GetFileInformationResponse(nullptr) {}
  ~GetFileInformationResponse() override;
  explicit constexpr GetFileInformationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFileInformationResponse(const GetFileInformationResponse& from);
  GetFileInformationResponse(GetFileInformationResponse&& from) noexcept
    : GetFileInformationResponse() {
    *this = ::std::move(from);
  }

  inline GetFileInformationResponse& operator=(const GetFileInformationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFileInformationResponse& operator=(GetFileInformationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFileInformationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFileInformationResponse* internal_default_instance() {
    return reinterpret_cast<const GetFileInformationResponse*>(
               &_GetFileInformationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetFileInformationResponse& a, GetFileInformationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFileInformationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFileInformationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetFileInformationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetFileInformationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFileInformationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFileInformationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFileInformationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.GetFileInformationResponse";
  }
  protected:
  explicit GetFileInformationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kFileAttributesFieldNumber = 2,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // uint64 file_attributes = 2;
  void clear_file_attributes();
  uint64_t file_attributes() const;
  void set_file_attributes(uint64_t value);
  private:
  uint64_t _internal_file_attributes() const;
  void _internal_set_file_attributes(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.GetFileInformationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  uint64_t file_attributes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class DeleteFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.DeleteFileResponse) */ {
 public:
  inline DeleteFileResponse() : DeleteFileResponse(nullptr) {}
  ~DeleteFileResponse() override;
  explicit constexpr DeleteFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFileResponse(const DeleteFileResponse& from);
  DeleteFileResponse(DeleteFileResponse&& from) noexcept
    : DeleteFileResponse() {
    *this = ::std::move(from);
  }

  inline DeleteFileResponse& operator=(const DeleteFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFileResponse& operator=(DeleteFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFileResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteFileResponse*>(
               &_DeleteFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DeleteFileResponse& a, DeleteFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.DeleteFileResponse";
  }
  protected:
  explicit DeleteFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.DeleteFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class DeleteDirectoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.DeleteDirectoryResponse) */ {
 public:
  inline DeleteDirectoryResponse() : DeleteDirectoryResponse(nullptr) {}
  ~DeleteDirectoryResponse() override;
  explicit constexpr DeleteDirectoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteDirectoryResponse(const DeleteDirectoryResponse& from);
  DeleteDirectoryResponse(DeleteDirectoryResponse&& from) noexcept
    : DeleteDirectoryResponse() {
    *this = ::std::move(from);
  }

  inline DeleteDirectoryResponse& operator=(const DeleteDirectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteDirectoryResponse& operator=(DeleteDirectoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteDirectoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteDirectoryResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteDirectoryResponse*>(
               &_DeleteDirectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeleteDirectoryResponse& a, DeleteDirectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteDirectoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteDirectoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteDirectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteDirectoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteDirectoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteDirectoryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteDirectoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.DeleteDirectoryResponse";
  }
  protected:
  explicit DeleteDirectoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.DeleteDirectoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class MoveFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.MoveFileResponse) */ {
 public:
  inline MoveFileResponse() : MoveFileResponse(nullptr) {}
  ~MoveFileResponse() override;
  explicit constexpr MoveFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveFileResponse(const MoveFileResponse& from);
  MoveFileResponse(MoveFileResponse&& from) noexcept
    : MoveFileResponse() {
    *this = ::std::move(from);
  }

  inline MoveFileResponse& operator=(const MoveFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveFileResponse& operator=(MoveFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveFileResponse* internal_default_instance() {
    return reinterpret_cast<const MoveFileResponse*>(
               &_MoveFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MoveFileResponse& a, MoveFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.MoveFileResponse";
  }
  protected:
  explicit MoveFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.MoveFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class LockFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.LockFileResponse) */ {
 public:
  inline LockFileResponse() : LockFileResponse(nullptr) {}
  ~LockFileResponse() override;
  explicit constexpr LockFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LockFileResponse(const LockFileResponse& from);
  LockFileResponse(LockFileResponse&& from) noexcept
    : LockFileResponse() {
    *this = ::std::move(from);
  }

  inline LockFileResponse& operator=(const LockFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockFileResponse& operator=(LockFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LockFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockFileResponse* internal_default_instance() {
    return reinterpret_cast<const LockFileResponse*>(
               &_LockFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LockFileResponse& a, LockFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LockFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LockFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LockFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LockFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LockFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.LockFileResponse";
  }
  protected:
  explicit LockFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.LockFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class SetEndOfFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.SetEndOfFileResponse) */ {
 public:
  inline SetEndOfFileResponse() : SetEndOfFileResponse(nullptr) {}
  ~SetEndOfFileResponse() override;
  explicit constexpr SetEndOfFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetEndOfFileResponse(const SetEndOfFileResponse& from);
  SetEndOfFileResponse(SetEndOfFileResponse&& from) noexcept
    : SetEndOfFileResponse() {
    *this = ::std::move(from);
  }

  inline SetEndOfFileResponse& operator=(const SetEndOfFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetEndOfFileResponse& operator=(SetEndOfFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetEndOfFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetEndOfFileResponse* internal_default_instance() {
    return reinterpret_cast<const SetEndOfFileResponse*>(
               &_SetEndOfFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetEndOfFileResponse& a, SetEndOfFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetEndOfFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetEndOfFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetEndOfFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetEndOfFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetEndOfFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetEndOfFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetEndOfFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.SetEndOfFileResponse";
  }
  protected:
  explicit SetEndOfFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.SetEndOfFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class SetAllocationSizeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.SetAllocationSizeResponse) */ {
 public:
  inline SetAllocationSizeResponse() : SetAllocationSizeResponse(nullptr) {}
  ~SetAllocationSizeResponse() override;
  explicit constexpr SetAllocationSizeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAllocationSizeResponse(const SetAllocationSizeResponse& from);
  SetAllocationSizeResponse(SetAllocationSizeResponse&& from) noexcept
    : SetAllocationSizeResponse() {
    *this = ::std::move(from);
  }

  inline SetAllocationSizeResponse& operator=(const SetAllocationSizeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAllocationSizeResponse& operator=(SetAllocationSizeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAllocationSizeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAllocationSizeResponse* internal_default_instance() {
    return reinterpret_cast<const SetAllocationSizeResponse*>(
               &_SetAllocationSizeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetAllocationSizeResponse& a, SetAllocationSizeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAllocationSizeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAllocationSizeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAllocationSizeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAllocationSizeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAllocationSizeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetAllocationSizeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAllocationSizeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.SetAllocationSizeResponse";
  }
  protected:
  explicit SetAllocationSizeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.SetAllocationSizeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class SetFileAttributesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.SetFileAttributesResponse) */ {
 public:
  inline SetFileAttributesResponse() : SetFileAttributesResponse(nullptr) {}
  ~SetFileAttributesResponse() override;
  explicit constexpr SetFileAttributesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetFileAttributesResponse(const SetFileAttributesResponse& from);
  SetFileAttributesResponse(SetFileAttributesResponse&& from) noexcept
    : SetFileAttributesResponse() {
    *this = ::std::move(from);
  }

  inline SetFileAttributesResponse& operator=(const SetFileAttributesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFileAttributesResponse& operator=(SetFileAttributesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFileAttributesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFileAttributesResponse* internal_default_instance() {
    return reinterpret_cast<const SetFileAttributesResponse*>(
               &_SetFileAttributesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SetFileAttributesResponse& a, SetFileAttributesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFileAttributesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFileAttributesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFileAttributesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFileAttributesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetFileAttributesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetFileAttributesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetFileAttributesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.SetFileAttributesResponse";
  }
  protected:
  explicit SetFileAttributesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.SetFileAttributesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// -------------------------------------------------------------------

class UnlockFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:drive_protocol.response.UnlockFileResponse) */ {
 public:
  inline UnlockFileResponse() : UnlockFileResponse(nullptr) {}
  ~UnlockFileResponse() override;
  explicit constexpr UnlockFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnlockFileResponse(const UnlockFileResponse& from);
  UnlockFileResponse(UnlockFileResponse&& from) noexcept
    : UnlockFileResponse() {
    *this = ::std::move(from);
  }

  inline UnlockFileResponse& operator=(const UnlockFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockFileResponse& operator=(UnlockFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockFileResponse* internal_default_instance() {
    return reinterpret_cast<const UnlockFileResponse*>(
               &_UnlockFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UnlockFileResponse& a, UnlockFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnlockFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnlockFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnlockFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnlockFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "drive_protocol.response.UnlockFileResponse";
  }
  protected:
  explicit UnlockFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // int64 status = 1;
  void clear_status();
  int64_t status() const;
  void set_status(int64_t value);
  private:
  int64_t _internal_status() const;
  void _internal_set_status(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:drive_protocol.response.UnlockFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Response_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateFileResponse

// int64 status = 1;
inline void CreateFileResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t CreateFileResponse::_internal_status() const {
  return status_;
}
inline int64_t CreateFileResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.CreateFileResponse.status)
  return _internal_status();
}
inline void CreateFileResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void CreateFileResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.CreateFileResponse.status)
}

// -------------------------------------------------------------------

// CloseFileResponse

// int64 status = 1;
inline void CloseFileResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t CloseFileResponse::_internal_status() const {
  return status_;
}
inline int64_t CloseFileResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.CloseFileResponse.status)
  return _internal_status();
}
inline void CloseFileResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void CloseFileResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.CloseFileResponse.status)
}

// -------------------------------------------------------------------

// ReadFileResponse

// int64 status = 1;
inline void ReadFileResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t ReadFileResponse::_internal_status() const {
  return status_;
}
inline int64_t ReadFileResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.ReadFileResponse.status)
  return _internal_status();
}
inline void ReadFileResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void ReadFileResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.ReadFileResponse.status)
}

// bytes buffer = 2;
inline void ReadFileResponse::clear_buffer() {
  buffer_.ClearToEmpty();
}
inline const std::string& ReadFileResponse::buffer() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.ReadFileResponse.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadFileResponse::set_buffer(ArgT0&& arg0, ArgT... args) {
 
 buffer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:drive_protocol.response.ReadFileResponse.buffer)
}
inline std::string* ReadFileResponse::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:drive_protocol.response.ReadFileResponse.buffer)
  return _s;
}
inline const std::string& ReadFileResponse::_internal_buffer() const {
  return buffer_.Get();
}
inline void ReadFileResponse::_internal_set_buffer(const std::string& value) {
  
  buffer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadFileResponse::_internal_mutable_buffer() {
  
  return buffer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadFileResponse::release_buffer() {
  // @@protoc_insertion_point(field_release:drive_protocol.response.ReadFileResponse.buffer)
  return buffer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadFileResponse::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    
  } else {
    
  }
  buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (buffer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    buffer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:drive_protocol.response.ReadFileResponse.buffer)
}

// -------------------------------------------------------------------

// WriteFileResponse

// int64 status = 1;
inline void WriteFileResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t WriteFileResponse::_internal_status() const {
  return status_;
}
inline int64_t WriteFileResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.WriteFileResponse.status)
  return _internal_status();
}
inline void WriteFileResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void WriteFileResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.WriteFileResponse.status)
}

// -------------------------------------------------------------------

// FlushFileBufferResponse

// int64 status = 1;
inline void FlushFileBufferResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t FlushFileBufferResponse::_internal_status() const {
  return status_;
}
inline int64_t FlushFileBufferResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.FlushFileBufferResponse.status)
  return _internal_status();
}
inline void FlushFileBufferResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void FlushFileBufferResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.FlushFileBufferResponse.status)
}

// -------------------------------------------------------------------

// GetFileInformationResponse

// int64 status = 1;
inline void GetFileInformationResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t GetFileInformationResponse::_internal_status() const {
  return status_;
}
inline int64_t GetFileInformationResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.GetFileInformationResponse.status)
  return _internal_status();
}
inline void GetFileInformationResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void GetFileInformationResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.GetFileInformationResponse.status)
}

// uint64 file_attributes = 2;
inline void GetFileInformationResponse::clear_file_attributes() {
  file_attributes_ = uint64_t{0u};
}
inline uint64_t GetFileInformationResponse::_internal_file_attributes() const {
  return file_attributes_;
}
inline uint64_t GetFileInformationResponse::file_attributes() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.GetFileInformationResponse.file_attributes)
  return _internal_file_attributes();
}
inline void GetFileInformationResponse::_internal_set_file_attributes(uint64_t value) {
  
  file_attributes_ = value;
}
inline void GetFileInformationResponse::set_file_attributes(uint64_t value) {
  _internal_set_file_attributes(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.GetFileInformationResponse.file_attributes)
}

// -------------------------------------------------------------------

// DeleteFileResponse

// int64 status = 1;
inline void DeleteFileResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t DeleteFileResponse::_internal_status() const {
  return status_;
}
inline int64_t DeleteFileResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.DeleteFileResponse.status)
  return _internal_status();
}
inline void DeleteFileResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void DeleteFileResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.DeleteFileResponse.status)
}

// -------------------------------------------------------------------

// DeleteDirectoryResponse

// int64 status = 1;
inline void DeleteDirectoryResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t DeleteDirectoryResponse::_internal_status() const {
  return status_;
}
inline int64_t DeleteDirectoryResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.DeleteDirectoryResponse.status)
  return _internal_status();
}
inline void DeleteDirectoryResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void DeleteDirectoryResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.DeleteDirectoryResponse.status)
}

// -------------------------------------------------------------------

// MoveFileResponse

// int64 status = 1;
inline void MoveFileResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t MoveFileResponse::_internal_status() const {
  return status_;
}
inline int64_t MoveFileResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.MoveFileResponse.status)
  return _internal_status();
}
inline void MoveFileResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void MoveFileResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.MoveFileResponse.status)
}

// -------------------------------------------------------------------

// LockFileResponse

// int64 status = 1;
inline void LockFileResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t LockFileResponse::_internal_status() const {
  return status_;
}
inline int64_t LockFileResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.LockFileResponse.status)
  return _internal_status();
}
inline void LockFileResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void LockFileResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.LockFileResponse.status)
}

// -------------------------------------------------------------------

// SetEndOfFileResponse

// int64 status = 1;
inline void SetEndOfFileResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t SetEndOfFileResponse::_internal_status() const {
  return status_;
}
inline int64_t SetEndOfFileResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.SetEndOfFileResponse.status)
  return _internal_status();
}
inline void SetEndOfFileResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void SetEndOfFileResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.SetEndOfFileResponse.status)
}

// -------------------------------------------------------------------

// SetAllocationSizeResponse

// int64 status = 1;
inline void SetAllocationSizeResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t SetAllocationSizeResponse::_internal_status() const {
  return status_;
}
inline int64_t SetAllocationSizeResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.SetAllocationSizeResponse.status)
  return _internal_status();
}
inline void SetAllocationSizeResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void SetAllocationSizeResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.SetAllocationSizeResponse.status)
}

// -------------------------------------------------------------------

// SetFileAttributesResponse

// int64 status = 1;
inline void SetFileAttributesResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t SetFileAttributesResponse::_internal_status() const {
  return status_;
}
inline int64_t SetFileAttributesResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.SetFileAttributesResponse.status)
  return _internal_status();
}
inline void SetFileAttributesResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void SetFileAttributesResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.SetFileAttributesResponse.status)
}

// -------------------------------------------------------------------

// UnlockFileResponse

// int64 status = 1;
inline void UnlockFileResponse::clear_status() {
  status_ = int64_t{0};
}
inline int64_t UnlockFileResponse::_internal_status() const {
  return status_;
}
inline int64_t UnlockFileResponse::status() const {
  // @@protoc_insertion_point(field_get:drive_protocol.response.UnlockFileResponse.status)
  return _internal_status();
}
inline void UnlockFileResponse::_internal_set_status(int64_t value) {
  
  status_ = value;
}
inline void UnlockFileResponse::set_status(int64_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:drive_protocol.response.UnlockFileResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace response
}  // namespace drive_protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Response_2eproto
